# 1-1 Java基础

## 1、Java 基础知识

### 1.1 Java语言特点

面向对象（封装，继承，多态）；平台无关性；支持多线程；可靠性；安全性；支持网络编程并且很方便；编译与解释并存；

### 1.2 JDK  &  JVM  &  JRE 的区别

- **JVM（Java 虚拟机）**是`运行 Java 字节码的虚拟机`。JVM 有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果。

- **JDK（Java Development Kit）** ，是`功能齐全的 Java SDK`。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。

- **JRE** 是 `Java 运行时环境`。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。

> 如果只是为了运行一下 Java 程序的话，那只需要安装 JRE 就可。如果需要进行一些 Java 编程方面的工作，那就需要安装 JDK 。但不绝对！

### 1.3 字节码

在 Java 中，**`JVM` 可以理解的代码就叫做字节码**（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。

Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。

>  **Java 是编译与解释共存的语言** 。

### 1.4 编译与解释

- **编译型** ：`编译型语言 会通过编译器将源代码一次性翻译成可被该平台执行的机器码。`一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。
- **解释型** ：`解释型语言 一句一句的将代码解释（interpret）为机器代码后再执行。`解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。

Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。

### 1.5 Java 与 C++ 异同点

Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是：

- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。
- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。

### 1.6  Oracle JDK 与 OpenJDK

+ `OpenJDK` 是一个参考模型并且是`完全开源`的，而 `Oracle JDK` 是 OpenJDK 的一个实现，并`不是完全开源`的；
+ `Oracle JDK` 比 OpenJDK `更稳定`（Oracle 内部团队进行单独研发）；
+ `Oracle JDK` 与 OpenJDK 相比提供了`更好的性能`；
+ Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。

## 2、基本语法

### 2.1 标识符与关键字

**标识符就是一个名字** ，而**关键字是被赋予特殊含义的标识符**。

> 所有的关键字都是小写的。

### 2.2 自增自减运算符

**前缀：先自增/减，再赋值**

当 `b = ++a` 时，先自增（自己增加 1），再赋值（赋值给 b）

**后缀：先赋值，再自增/减**

当 `b = a++` 时，先赋值(赋值给 b)，再自增（自己增加 1）

### 2.3 成员变量与局部变量

|        | 成员变量                                                     | 局部变量                                                    |
| :----: | ------------------------------------------------------------ | ----------------------------------------------------------- |
|  语法  | 属于类的，可以被 `public`,`private`,`static` 等修饰符所修饰，能被 `final` 所修饰 | 代码块或方法中定义的变量或方法的参数，只能被 `final` 所修饰 |
|  存储  | `static` 修饰，属于类，堆内存；否则属于实例，栈内存          | 栈内存                                                      |
|  生存  | 与对象生存周期一致                                           | 方法调用结束则消亡                                          |
| 默认值 | 以类型的默认值而赋值（ `final` 修饰的成员变量必须显式地赋值） | 不会自动赋值                                                |

### 2.4 静态变量

`静态变量`可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。

通常情况下，静态变量会被 `final` 关键字修饰成为常量。

### 2.5 静态方法与非静态成员

+ `静态方法`是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。

+ `非静态成员`属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。

> **问：静态方法为什么不能调用非静态成员?**
>
> 在类的`非静态成员`不存在的时候`静态成员`就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

### 2.6 静态方法与实例方法

**静态方法：**

+ 在外部被调用时，可以使用 `类名.方法名` 和 `对象.方法名` 两种方式（但推荐用前者）；
+ 在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员。

**实例方法：**

+ 被调用时，需要先实例化（创建对象），使用 `对象.方法名` 的方式来调用；
+ 在访问本类的成员时，没有任何限制。

### 2.7 重载与重写

**重载：**

指的是同样的一个方法，能够根据输入数据的不同，做出不同的处理，如：

```java
StringBuilder sb = new StringBuilder();
StringBuilder sb2 = new StringBuilder("HelloWorld");
```

即：`同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理`。

**重写：**

重写发生在运行期，是 `子类对父类的允许访问的方法的实现过程进行重新编写`。

+ 方法名、参数列表必须相同；
+ 子类方法`返回值`类型应比父类方法返回值类型更小（即可以是引用类型的子类）或相等；
+ 抛出的异常范围`小于等于`父类；
+ 访问修饰符范围`大于等于`父类；
+ 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明；
+ 构造方法无法被重写。

即：`重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。`

## 3、数据类型

### 3.1 八种基本数据类型

- 4 种整数型：`byte`、`short`、`int`、`long`
- 2 种浮点型：`float`、`double`
- 1 种字符类型：`char`
- 1 种布尔型：`boolean`

| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                   |
| :-------: | :--: | :--: | :-----: | ------------------------------------------ |
|  `byte`   |  8   |  1   |    0    | -128 ~ 127                                 |
|  `short`  |  16  |  2   |    0    | -32768 ~ 32767                             |
|   `int`   |  32  |  4   |    0    | -2147483648 ~ 2147483647                   |
|  `long`   |  64  |  8   |   0L    | -9223372036854775808 ~ 9223372036854775807 |
|  `char`   |  16  |  2   | 'u0000' | 0 ~ 65535                                  |
|  `float`  |  32  |  4   |   0f    | 1.4E-45 ~ 3.4028235E38                     |
| `double`  |  64  |  8   |   0d    | 4.9E-324 ~ 1.7976931348623157E308          |
| `boolean` |  1   |      |  false  | true、false                                |

>  `boolean`的 字节数，官方文档未明确定义。
>
>  `long` 类型的数据要在数值后面加 **L** 。

这**八种基本类型**都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。

### 3.2 基本类型和包装类型的区别

- 包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。
- 包装类型可用于泛型，而基本类型不可以。
- 基本数据类型的**局部变量存放在 Java 虚拟机栈中的局部变量表中**，基本数据类型的**成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中**。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。
- 相比于对象类型， 基本数据类型占用的空间非常小。

### 3.3 包装类型的缓存机制与比较





### 1.3 包装类型的常量池

Java 基本类型的包装类的大部分都实现了常量池技术。

`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据

`Character` 创建了数值在 **[0,127]** 范围的缓存数据

`Boolean` 直接返回 `True` or `False`。

### 1.4 静态方法为什么不能调用非静态成员?

1. 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
2. 在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

### 1.5 构造方法有哪些特点？是否可被 override?

构造方法特点如下：

- 名字与类名相同。
- 没有返回值，但不能用 void 声明构造函数。
- 生成类的对象时自动执行，无需调用。

构造方法不能被重写,但是**可以重载**,所以你可以看到一个类中有多个构造函数的情况。

### 一个类的实例从new 开始的过程

## 2、面向对象

### 2.1 面向对象三大特征

- 封装 : 把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。
- 继承 : 不同类型的对象，相互之间经常有一定数量的共同点。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。
- 多态 : 表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。

### 2.2 接口和抽象类有什么共同点和区别？

**共同点**

- 都不能被实例化
- 都可以包含抽象方法
- 都可以有默认实现方法(接口1.8之后可以使用default定义)

**区别**

- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系

- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

### Java的多态与实现

## 3、Java常用对象

### 3.1 字符串拼接用“+” 还是 StringBuilder?

Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的元素符。不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：**编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象**。

### 3.2 String 类型的变量和常量做“+”运算时发生了什么？

**对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。**并且，**字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池**，这个得益于编译器的优化(常量折叠)。而引用的值在程序编译期是无法确定的，编译器无法对其进行优化。不过，字符串使用 `final` 关键字声明之后，可以让编译器当做常量来处理。

### Integer 的大小

## 4、泛型

### Java 泛型了解么？什么是类型擦除？

- **Java 泛型（generics）** 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制
- Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。
- 泛型一般有三种使用方式: 泛型类、泛型接口、泛型方法。

## 5、反射

反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。

### 反射机制优缺点

- **优点** ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利
- **缺点** ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。

### 反射的应用场景

像 Spring/Spring Boot、MyBatis 等等,**这些框架中大量使用了动态代理，而动态代理的实现也依赖反射。**

**注解** 的实现也用到了反射 , 可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。

## 6、注解

常见的解析方法有两种：

- **编译期直接扫描** ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用`@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- **运行期通过反射处理** ：像框架中自带的注解(比如 Spring 框架的 `@Value` 、`@Component`)都是通过反射来进行处理的。



## 7、异常

在 Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类:

- **`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。
- **`Error`** ：`Error` 属于程序无法处理的错误 。例如Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

### 受检查异常和不受检查异常的区别

- Java 代码在编译过程中，如果**受检查异常**没有被 `catch`/`throw` 处理的话，就没办法通过编译常见的受检查异常有： IO 相关的异常、`ClassNotFoundException` 、`SQLException`...

- 即使不处理**不受检查异常**也可以正常通过编译 , 例如：`NullPointerException`、`NumberFormatException`（字符串转换为数字）、`ArrayIndexOutOfBoundsException`（数组越界）、`ClassCastException`（类型转换错误）、`ArithmeticException`（算术错误）等



### finally 中的代码一定会执行吗？

不一定

- 比如说 `finally` 之前虚拟机被终止运行的话，finally 中的代码就不会被执行

- 程序所在的线程死亡

- 关闭 CPU



## 8、I/O

### Java 序列化中如果有些字段不想进行序列化，怎么办？

对于不想进行序列化的变量，使用 `transient` 关键字修饰。

`transient` 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。

关于 `transient` 还有几点注意：

- `transient` 只能修饰变量，不能修饰类和方法。
- `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
- `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。



### Java 中 IO 流分为几种?

- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。



### 既然有了字节流,为什么还要有字符流?

字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。



### Java 中 3 种常见 IO 模型

- BIO : 同步阻塞IO

- NIO : 多路复用IO
- AIO : 异步IO