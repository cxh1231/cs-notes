

# 1-4 Java 虚拟机

## 1、Java 内存（结构、数据区域）

> 基于JDK 1.8

在 Java 虚拟机的自动内存管理机制下，无需手动 delete/free 操作，不容易出现内存泄露和内存溢出问题，全权交给虚拟机管理。但一旦出现内存泄露和溢出等问题，需要了解虚拟机的内存管理机制。

**Java 虚拟机**在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域，如下图所示。

![image-20220729151844436](https://img.zxdmy.com/2022/202207291602860.png)

下面详细讲述各个内存区域。先从线程私有区域开始：

> **线程私有内存区域** 的 **生命周期和线程相同**，随着线程的创建而创建，随着线程的死亡而死亡。

### 1.1 虚拟机栈

`Java 虚拟机栈` ，是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过**本地方法栈** 实现的，**其他所有的 Java 方法调用都是通过虚拟机栈来实现的**（也需要和其他运行时数据区域比如程序计数器配合）。

**方法调用** 的数据需要通过栈进行传递，每一次方法调用都会有一个对应的 `栈帧` 被压入栈中，每一个方法调用结束后，都会有一个 `栈帧` 被弹出。

**虚拟机栈** 由一个个`栈帧`组成，而每个栈帧中都拥有：`局部变量表`、`操作数栈`、`动态链接`、`方法返回地址`。

+ **局部变量表**：存放编译期可知的**各种数据类型**（如8种基本数据类型）、**对象引用**（如指向对象起始地址的引用指针、指向一个代表对象的句柄或其他与此对象相关的位置）。
+ **操作数栈**：作为**方法调用**的中转站使用，用于存放方法执行过程中产生的中间计算结果，以及计算过程中产生的临时变量。
+ **动态链接**：服务一个方法需要调用其他方法的场景。

> 关于**动态链接**：Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为 `符号引用` 保存在 Class 文件的`常量池`里。当一个方法要调用其他方法，需要将`常量池`中指向方法的`符号引用`转化为其在内存地址中的`直接引用`。**动态链接的作用就是为了将符号引用转换为调用方法的直接引用**。
>
> ![image-20220729153941829](https://img.zxdmy.com/2022/202207291539415.png)

**虚拟机栈** 和数据结构上的栈类似，也是 **先进后出** 的数据结构，只支持**出栈**和**入栈**两种操作。

![image-20220729153145253](https://img.zxdmy.com/2022/202207291531704.png)

程序运行中，**虚拟机栈** 可能会出现两种错误：

- `StackOverFlowError`： 若虚拟机栈的内存大小不允许动态扩展，那么当线程请求虚拟机栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
- `OutOfMemoryError`： 如果虚拟机栈的内存大小可以动态扩展， 但是虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出 `OutOfMemoryError` 异常。

### 1.2 本地方法栈

**本地方法栈** 为虚拟机使用到的 `Native 方法` 服务。

本地方法被执行的时候，在**本地方法栈**也会创建一个`栈帧`，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。

>  在 `HotSpot 虚拟机` 中，**本地方法栈 和 Java 虚拟机栈 合二为一。**

### 1.3 程序计数器

程序计数器是一块较小的内存空间，可以看作 `当前线程所执行的字节码的行号指示器`。

其作用如下：

+ `字节码解释器` 通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
+ 在 `多线程` 的情况下，程序计数器用于 **记录当前线程执行的位置**，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

> 正是为了线程切换时能恢复到正确的执行位置，所以每条线程都需要有一个独立的程序计数器，以保证各线程之间计数器互不影响，独立存储。

> 接下来是 线程共享区域：

### 1.4 堆

**堆**，是JVM 所管理的内存中最大的一块，所有线程共享堆的空间，在虚拟机启动时创建。

**堆 的唯一目的是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

> 但是：所有的对象都分配到堆中，太绝对！
> 从 JDK 1.7 开始已经默认开启`逃逸分析`，如果某些方法中的`对象引用`没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以`直接在栈上分配内存`。

**Java 堆** 是 `垃圾收集器` 管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。

从**垃圾回收**的角度，由于`收集器`基本都采用`分代垃圾收集算法`，所以 **Java 堆** 还可以细分为新生代和老年代，再细致一点有：Eden、Survivor、Old 等空间。

> 进一步划分的目的是更好地回收内存，或者更快地分配内存。

在 JDK 7 版本及 JDK 7 版本之前，**堆内存** 被通常分为下面三部分：

1. 新生代内存（Young Generation）
2. 老年代内存（Old Generation）
3. 永久代内存（Permanent Generation）

**JDK 8 之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存**。

下图所示的 `Eden` 区、两个 `Survivor` 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。

![image-20220729170939107](https://img.zxdmy.com/2022/202207291709859.png)

> 关于各个年代内存，涉及到垃圾回收算法的使用，详见后文。

程序运行时，堆 中最容易出现 `OutOfMemoryError` 错误，比如：

+ `java.lang.OutOfMemoryError: GC Overhead Limit Exceeded` ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
+ `java.lang.OutOfMemoryError: Java heap space` :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。
+ ……

### 1.5 方法区（元空间实现）

**方法区** 属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。

> 在不同的虚拟机实现上，方法区的实现是不同的。

当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。

**方法区** 会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

**方法区和永久代、元空间 的关系**：`永久代`以及`元空间`是 HotSpot 虚拟机对虚拟机规范中`方法区`的两种实现方式。

+ **永久代** 是 JDK 1.8 之前方法区的实现，
+ **元空间** 是 JDK 1.8 及以后方法区的实现。

![image-20220729191012289](https://img.zxdmy.com/2022/202207291910278.png)

> **为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**
>
> 1. 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
> 2. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
> 3. 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。

### 附：运行时常量池（方法区内）

`Class` 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种 `字面量`（Literal）和 `符号引用`（Symbolic Reference）的 **常量池表(Constant Pool Table)** 。

+ `字面量` 是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量
+ `符号引用`包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。

**常量池表** 会在类加载后存放到方法区的 **运行时常量池** 中。

**运行时常量池** 的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。

当`常量池`无法再申请到内存时会抛出 `OutOfMemoryError` 错误。

### 附：字符串常量池（方法区 → 堆）

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了**避免字符串的重复创建**。

JDK1.7 之前，**字符串常量池**存放在`永久代`。JDK1.7 **字符串常量池**和**静态变量**从`永久代`移动了 Java `堆`中，如下图所示。

![image-20220731140235334](https://img.zxdmy.com/2022/202207311402801.png)

> **JDK 1.7 为什么要将字符串常量池移动到堆中？**
>
> 因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集（Full GC）的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够**更高效及时地回收字符串内存**。

> + **运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的；**
>
> + **Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。**

### 附：直接内存（不是 运行时数据区 的部分）

> **直接内存并不是虚拟机运行时数据区的一部分**，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 错误出现。

JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## 2、类的生命周期

一个类的完整生命周期如下：

![image-20220729172031135](https://img.zxdmy.com/2022/202207291720677.png)

**系统加载 Class 类型的文件**包含 **加载**、**链接** 和 **初始化** 三步。

### 2.1 加载

**加载** 是类生命周期的第一步，主要完成下面 3 件事情：

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口

一个 **非数组类** 的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步还可以自定义**类加载器**去控制字节流的获取方式（重写一个类加载器的 `loadClass()` 方法）。

> **数组类型** 不通过类加载器创建，它**由 Java 虚拟机直接创建。**

> 所有的类都由类加载器加载，加载的作用就是将 `.class`文件加载到内存。

#### 类加载器

**JVM** 中内置了三个重要的 `ClassLoader`，除了 `BootstrapClassLoader` 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由 C++实现，负责加载 `%JAVA_HOME%/lib`目录下的 jar 包和类或者被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的 jar 包。
3. **AppClassLoader(应用程序类加载器)** ：面向我们用户的加载器，负责加载 `当前应用 classpath` 下的所有 `jar` 包和`类`。

#### 双亲委派模型

每一个类都有一个对应它的类加载器。系统中的 `ClassLoader` 在协同工作的时候会默认使用 **双亲委派模型** 。

在 **类加载** 时，系统会首先判断当前类是否被加载过：

+ 已经被加载的类会直接返回，否则才会尝试加载。

加载的时候，首先会把该请求委派给**父类加载器**的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。

+ 当父类加载器无法处理时，才由自己来处理。

+ 当父类加载器为 null 时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。

![image-20220731153739081](https://img.zxdmy.com/2022/202207311537586.png)

> **null 并不代表没有父类加载器，而是 `BootstrapClassLoader`** 。
>
> 类加载器之间的“父子”关系不是通过继承来体现的，是由“**优先级**”来决定。

**亲委派模型的好处：**

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。

如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现多个不同的 `Object` 类。

**自定义类加载器：**

除了 `BootstrapClassLoader` ，其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`。

如果我们要自定义自己的类加载器，需要继承 `ClassLoader`。

### 2.2 连接

> **加载阶段** 和 **连接阶段** 的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能已经开始了。

#### 2.2.1 验证

**验证阶段** 主要对文件格式、元数据、字节码、符号引用 进行验证。

![image-20220731154258988](https://img.zxdmy.com/2022/202207311543209.png)

#### 2.2.2 准备

**准备阶段是正式为 `类变量` 分配内存并 `设置类变量初始值` 的阶段**，这些内存都将在方法区中分配。

详情如下：

+ **准备阶段** 只对 **类变量** 进行内存分配（即 Class Variables ，静态变量，被 `static` 关键字修饰的变量），不包括 实例变量（实例变量会在对象实例化时随着对象一块分配在 Java 堆中。）
+ 从概念上讲，类变量所使用的内存都应当在 **方法区** 中进行分配。而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的`字符串常量池`、`静态变量`等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。
+ 这里所设置的**初始值**，通常情况下是数据类型默认的零值（如 0、0L、null、false 等）
    + 如： `public static int value=111` ， value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。
    + 但是：public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。

#### 2.2.3 解析

**解析阶段** 是虚拟机将常量池内的`符号引用替换为直接引用`的过程。

解析动作主要针对`类或接口`、`字段`、`类方法`、`接口方法`、`方法类型`、`方法句柄`和`调用限定符` 7 类符号引用进行。

+ **符号引用**就是一组符号来描述目标，可以是任何字面量。
+ **直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

> 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

### 2.3 初始化

**初始化阶段** 是执行初始化方法 `<clinit> ()` 的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

> 说明： `<clinit> ()`方法是编译之后自动生成的。

对于`<clinit> ()` 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 `<clinit> ()` 方法是**带锁线程安全**，所以在多线程环境下进行类初始化的话可能会引起多个进程阻塞，并且这种阻塞很难被发现。

以下 5 种情况，必须对类进行初始化：

1. 当遇到 `new` 、 `getstatic`、`putstatic` 或 `invokestatic` 这 4 条直接码指令时（比如 `new` 一个类， 读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时）：
    - 当 jvm 执行 `new` 指令时会初始化类。即**当程序创建一个类的实例对象**。
    - 当 jvm 执行 `getstatic` 指令时会初始化类。即**程序访问类的静态变量**(不是静态常量，常量会被加载到运行时常量池)。
    - 当 jvm 执行 `putstatic` 指令时会初始化类。即程序给类的静态变量赋值。
    - 当 jvm 执行 `invokestatic` 指令时会初始化类。即程序调用类的静态方法。
2. 使用 `java.lang.reflect` 包的方法对类进行**反射调用**时，如 `Class.forname("...")`, `newInstance()` 等等。如果类没初始化，需要触发其初始化。
3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 `main` 方法的那个类)，虚拟机会先初始化这个类。
5. `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 `findStaticVarHandle` 来初始化要调用的类。

另外：当一个接口中定义了 JDK8 新加入的**默认方法**（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化

### 2.4 卸载

卸载类即该类的 Class 对象被 GC。

卸载类需要满足 3 个要求:

1. 该类的所有的实例对象都已被 GC，也就是说堆**不存在该类的实例对象**。
2. 该类在其他任何地方**没有被引用**
3. 该类的**类加载器的实例已被 GC**

> 由 jvm 自带的类加载器（ `BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` ）加载的类是不会被卸载的，因为它们负责加载 JDK 提供的类。但由我们自定义的类加载器加载的类是可能被卸载的。

## 3、垃圾回收（GC）

> 如果没有特殊说明，都是针对的是 HotSpot 虚拟机。

当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。

Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 **堆** 内存中对象的分配与回收。

**Java 堆是垃圾收集器管理的主要区域**，因此也被称作 **GC 堆（Garbage Collected Heap）**。

从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)

**下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于`新生代`，中间一层属于`老年代`，最下面一层属于`永久代`。**

![image-20220731165419362](https://img.zxdmy.com/2022/202208010958045.png)

### 4.1 内存的分配与回收

#### 对象优先在 Eden 区分配

大多数情况下，对象在**新生代**中 Eden 区分配。

当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 **Minor GC（新生代垃圾回收）**。

#### 大对象直接进入老年代

**大对象** 就是需要大量连续内存空间的对象（比如：字符串、数组）。

大对象直接进入老年代主要是为了避免为大对象分配内存时由于**分配担保机制**带来的复制而降低效率。

> **空间分配担保** 是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。

#### 长期存活的对象将进入老年代

由于 Java 虚拟机采用分代收集的思想来管理内存，为了内存回收时识别哪些对象放在新生代，哪些对象放在老年代，虚拟机给每个对象一个**对象年龄计数器**（Age）。

1. 大多数情况下，对象首先被分配在 `Eden` 区域；
2. `Eden` 出生的对象，经过一次 `Minor GC` 后仍存活，并且能被 `Survivor` 容纳：将被移动到 `Survivor` 空间（`s0` 或者 `s1`）中，并将对象年龄设为 `1`
3. 对象在 `Survivor` 中每熬过一次 `MinorGC`,年龄就增加 `1` 岁
4. 当该对象年龄增加到一定程度（默认为 15 岁，但有出入，详见下文），就会被晋升到`老年代`中。

> 对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

> `Hotspot` 遍历所有对象时，按照**年龄从小到大**对其所占用的大小进行累积，当累积的某个年龄大小超过了 `survivor` 区的 `50%` 时（默认值是 `50%`，可以通过参数 `-XX:TargetSurvivorRatio=percent` 来设置），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值。

#### GC 分类

**部分收集 (Partial GC)：**

- **新生代收集（Minor GC / Young GC）**：只对新生代进行垃圾收集；
- **老年代收集（Major GC / Old GC）**：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- **混合收集（Mixed GC）**：对整个新生代和部分老年代进行垃圾收集。

**整堆收集 (Full GC)：**收集整个 Java 堆和方法区。

### 4.2 死亡对象的判断

**堆** 中几乎放着所有的**对象实例**，对 **堆** 垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）

#### 引用计数法

给对象中添加一个引用计数器：

- 每当有一个地方引用它，计数器就加 1；
- 当引用失效，计数器就减 1；
- 任何时候计数器为 0 的对象就是不可能再被使用的。

> **这个方法实现简单，效率高，但是目前主流的虚拟机中`并没有`选择这个算法来管理内存，其最主要的原因是它很难解决对象之间`相互循环引用`的问题。**

相互引用示例：

```java
public class ReferenceCountingGc {
    Object instance = null;
    public static void main(String[] args) {
        ReferenceCountingGc objA = new ReferenceCountingGc();
        ReferenceCountingGc objB = new ReferenceCountingGc();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
    }
}
```

除了对象 `objA` 和 `objB` 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，无法被回收。

#### 可达性分析法

即通过一系列被称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为**引用链**，当一个对象到 **GC Roots** 没有任何**引用链**相连的话，则证明此对象是不可用的，需要被回收。

下图中的 `Object 6 ~ Object 10` 之间虽有引用关系，但它们到 **GC Roots** 不可达，因此需要被回收的对象。

![image-20220801095635336](https://img.zxdmy.com/2022/202208010956419.png)

**可以作为 GC Roots 的对象**

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

### 4.3 类型引用

> 无论是通过 **引用计数法** 判断对象引用数量，还是通过 **可达性分析法** 判断对象的引用链是否可达，**判定对象的存活都与“引用”有关。**

JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为**强引用**、**软引用**、**弱引用**、**虚引用**四种（引用强度逐渐减弱）。

#### 强引用

**强引用** 是使用最普遍的引用，我们使用的大部分引用都属于强引用。

**如果一个对象具有强引用，那该对象必不可少，垃圾回收器 绝不会回收它。**

当内存不足时，也不会回收，而是抛出  OutOfMemoryError 错误使程序异常终止。

#### 软引用

具有 **软引用** 的对象可有可无。

内存足够时，垃圾回收器 不会回收它，内存不足时，垃圾回收器 会回收这些对象的内存。

**软引用** 可用来实现内存敏感的高速缓存。

> **软引用** 可以和一个**引用队列**（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

#### 弱引用

具有 **弱引用** 的对象可有可无。

**弱引用** 的对象拥有更短暂的生命周期，垃圾回收器线程一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。（垃圾回收器 是一个优先级很低的线程， 不一定会很快发现那些只具有弱引用的对象。）

> **弱引用** 可以和一个**引用队列**（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

#### 虚引用

如果一个对象仅持有**虚引用**，那么它就和**没有任何引用**一样，在任何时候都可能被垃圾回收。

### 4.4 废弃常量与无用类

#### 废弃常量

> **运行时常量池** 主要回收的是**废弃常量**。

假如在字符串常量池中存在字符串 "abc"，如果当前**没有任何 String 对象引用该字符串常量**的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。

#### 无用类

> **方法区**主要回收的是**无用的类**。但不是必然回收！

**无用类** 满足以下 3 个条件：

- 该类所有的实例都已经被回收，也就是 Java 堆中**不存在该类的任何实例**。
- **加载该类的 `ClassLoader` 已经被回收。**
- 该类对应的 `java.lang.Class` 对象**没有在任何地方被引用**，无法在任何地方通过反射访问该类的方法。

### 4.5 垃圾收集算法

#### 标记-清除 算法

该算法包含 **标记** 和 **清除** 两个阶段。

1. 标记 所有不需要回收的对象；
2. 统一回收所有 未被标记 的对象。

该算法存在两个问题：

+ 效率问题
+ 空间问题：标记清除后会产生大量不连续的空间碎片。

> 这是最基础的收集算法，后续算法均对其不足进行改进。

#### 标记-复制 算法

为了**解决 效率问题**，该算法出现。

1. 首先将内存分为大小相同的两块，每次使用其中的一块；
2. 当一块内存使用完后，将存活的对象复制到另一块；
3. 清理掉使用完成的内存块。

#### 标记-整理 算法

根据**老年代**的特点提出的一种标记算法，标记过程与“标记-清除”算法一致。

但是：**不直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。**

#### 分代收集算法

> 当前虚拟机的垃圾收集都采用分代收集算法。
>
> 其实就是根据对象存活周期的不同，将内存分为几块。

一般将 java 堆分为**新生代**和**老年代**，这样我们就可以**根据各个年代的特点选择合适的垃圾收集算法**。

+ **新生代**：每次收集，都将有大量的对象死去，故可选择 **标记-复制 算法**。
+ **老年代**：对象存活几率较高，没有额外的空间对其进行分配担保，故选择 “**标记-清除**”或“**标记-整理**”算法进行垃圾收集。

> **这也是为什么要分 新生代 和 老年代 的原因之一。**

### 4.6 垃圾收集器

#### Serial 收集器



#### ParNew 收集器



#### Parallel Scavenge 收集器



#### Serial Old 收集器



#### Parallel Old 收集器



#### CMS 收集器



#### G1 收集器



#### ZGC 收集器





## 4、JVM 参数与调优







## jvm 调优

## 什么时候会发生 GC

## 有哪些 GC 方式

## 服务器 oom 了怎么解决

##  G1 回收器和 CMS 区别

## G1 垃圾回收器有什么参数需要配置吗

## 比如 try catch 在 jvm 怎么实现的，

## GC算法：新生代、老年代