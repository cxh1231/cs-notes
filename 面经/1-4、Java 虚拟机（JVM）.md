

# 1-4 Java 虚拟机

## 1、Java 内存（结构）

在 Java 虚拟机的自动内存管理机制下，无需手动 delete/free 操作，不容易出现内存泄露和内存溢出问题，全权交给虚拟机管理。但一旦出现内存泄露和溢出等问题，需要了解虚拟机的内存管理机制。

### 1.1 数据区域（基于JDK 1.8）

**Java 虚拟机**在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域，如下图所示。

![image-20220729151844436](https://img.zxdmy.com/2022/202207291602860.png)

下面详细讲述各个内存区域。先从线程私有区域开始：

> **线程私有内存区域** 的 **生命周期和线程相同**，随着线程的创建而创建，随着线程的死亡而死亡。

#### A. 虚拟机栈

`Java 虚拟机栈` ，是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过**本地方法栈** 实现的，**其他所有的 Java 方法调用都是通过虚拟机栈来实现的**（也需要和其他运行时数据区域比如程序计数器配合）。

**方法调用** 的数据需要通过栈进行传递，每一次方法调用都会有一个对应的 `栈帧` 被压入栈中，每一个方法调用结束后，都会有一个 `栈帧` 被弹出。

**虚拟机栈** 由一个个`栈帧`组成，而每个栈帧中都拥有：`局部变量表`、`操作数栈`、`动态链接`、`方法返回地址`。

+ **局部变量表**：存放编译期可知的**各种数据类型**（如8种基本数据类型）、**对象引用**（如指向对象起始地址的引用指针、指向一个代表对象的句柄或其他与此对象相关的位置）。
+ **操作数栈**：作为**方法调用**的中转站使用，用于存放方法执行过程中产生的中间计算结果，以及计算过程中产生的临时变量。
+ **动态链接**：服务一个方法需要调用其他方法的场景。

> 关于**动态链接**：Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为 `符号引用` 保存在 Class 文件的`常量池`里。当一个方法要调用其他方法，需要将`常量池`中指向方法的`符号引用`转化为其在内存地址中的`直接引用`。**动态链接的作用就是为了将符号引用转换为调用方法的直接引用**。
>
> ![image-20220729153941829](https://img.zxdmy.com/2022/202207291539415.png)

**虚拟机栈** 和数据结构上的栈类似，也是 **先进后出** 的数据结构，只支持**出栈**和**入栈**两种操作。

![image-20220729153145253](https://img.zxdmy.com/2022/202207291531704.png)

程序运行中，**虚拟机栈** 可能会出现两种错误：

- `StackOverFlowError`： 若虚拟机栈的内存大小不允许动态扩展，那么当线程请求虚拟机栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
- `OutOfMemoryError`： 如果虚拟机栈的内存大小可以动态扩展， 但是虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出 `OutOfMemoryError` 异常。

#### B. 本地方法栈

**本地方法栈** 为虚拟机使用到的 `Native 方法` 服务。

本地方法被执行的时候，在**本地方法栈**也会创建一个`栈帧`，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。

>  在 `HotSpot 虚拟机` 中，**本地方法栈 和 Java 虚拟机栈 合二为一。**

#### C. 程序计数器

程序计数器是一块较小的内存空间，可以看作 `当前线程所执行的字节码的行号指示器`。

其作用如下：

+ `字节码解释器` 通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
+ 在 `多线程` 的情况下，程序计数器用于 **记录当前线程执行的位置**，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

> 正是为了线程切换时能恢复到正确的执行位置，所以每条线程都需要有一个独立的程序计数器，以保证各线程之间计数器互不影响，独立存储。

> 接下来是 线程共享区域：

#### D. 堆

**堆**，是JVM 所管理的内存中最大的一块，所有线程共享堆的空间，在虚拟机启动时创建。

**堆 的唯一目的是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

> 但是：所有的对象都分配到堆中，太绝对！
> 从 JDK 1.7 开始已经默认开启`逃逸分析`，如果某些方法中的`对象引用`没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以`直接在栈上分配内存`。

**Java 堆** 是 `垃圾收集器` 管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。

从**垃圾回收**的角度，由于`收集器`基本都采用`分代垃圾收集算法`，所以 **Java 堆** 还可以细分为新生代和老年代，再细致一点有：Eden、Survivor、Old 等空间。

> 进一步划分的目的是更好地回收内存，或者更快地分配内存。

在 JDK 7 版本及 JDK 7 版本之前，**堆内存** 被通常分为下面三部分：

1. 新生代内存（Young Generation）
2. 老年代内存（Old Generation）
3. 永久代内存（Permanent Generation）

**JDK 8 之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存**。

下图所示的 `Eden` 区、两个 `Survivor` 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。

![image-20220729170939107](https://img.zxdmy.com/2022/202207291709859.png)

> 关于各个年代内存，涉及到垃圾回收算法的使用，详见后文。

程序运行时，堆 中最容易出现 `OutOfMemoryError` 错误，比如：

+ `java.lang.OutOfMemoryError: GC Overhead Limit Exceeded` ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
+ `java.lang.OutOfMemoryError: Java heap space` :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。
+ ……

#### E. 方法区（元空间实现）

**方法区** 属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。

> 在不同的虚拟机实现上，方法区的实现是不同的。

当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。

**方法区** 会存储已被虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

**方法区和永久代、元空间 的关系**：`永久代`以及`元空间`是 HotSpot 虚拟机对虚拟机规范中`方法区`的两种实现方式。

+ **永久代** 是 JDK 1.8 之前方法区的实现，
+ **元空间** 是 JDK 1.8 及以后方法区的实现。

![image-20220729191012289](https://img.zxdmy.com/2022/202207291910278.png)

> **为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**
>
> 1. 整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
> 2. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
> 3. 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。

#### 附：运行时常量池（方法区内）

`Class` 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种 `字面量`（Literal）和 `符号引用`（Symbolic Reference）的 **常量池表(Constant Pool Table)** 。

+ `字面量` 是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量
+ `符号引用`包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。

**常量池表** 会在类加载后存放到方法区的 **运行时常量池** 中。

**运行时常量池** 的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。

当`常量池`无法再申请到内存时会抛出 `OutOfMemoryError` 错误。

#### 附：字符串常量池（方法区 → 堆）

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了**避免字符串的重复创建**。

JDK1.7 之前，**字符串常量池**存放在`永久代`。JDK1.7 **字符串常量池**和**静态变量**从`永久代`移动了 Java `堆`中，如下图所示。

![image-20220731140235334](https://img.zxdmy.com/2022/202207311402801.png)

> **JDK 1.7 为什么要将字符串常量池移动到堆中？**
>
> 因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集（Full GC）的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够**更高效及时地回收字符串内存**。

> + **运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的；**
>
> + **Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。**

#### 附：直接内存（不是 运行时数据区 的部分）

> **直接内存并不是虚拟机运行时数据区的一部分**，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 错误出现。

JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

## 2、类的生命周期

一个类的完整生命周期如下：

![image-20220729172031135](https://img.zxdmy.com/2022/202207291720677.png)

**系统加载 Class 类型的文件**包含 **加载**、**链接** 和 **初始化** 三步。

### 2.1 加载

**加载** 是类生命周期的第一步，主要完成下面 3 件事情：

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口

一个 **非数组类** 的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步还可以自定义**类加载器**去控制字节流的获取方式（重写一个类加载器的 `loadClass()` 方法）。

> **数组类型** 不通过类加载器创建，它**由 Java 虚拟机直接创建。**

> 所有的类都由类加载器加载，加载的作用就是将 `.class`文件加载到内存。

#### 类加载器

**JVM** 中内置了三个重要的 `ClassLoader`，除了 `BootstrapClassLoader` 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由 C++实现，负责加载 `%JAVA_HOME%/lib`目录下的 jar 包和类或者被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的 jar 包。
3. **AppClassLoader(应用程序类加载器)** ：面向我们用户的加载器，负责加载 `当前应用 classpath` 下的所有 `jar` 包和`类`。

#### 双亲委派模型

每一个类都有一个对应它的类加载器。系统中的 `ClassLoader` 在协同工作的时候会默认使用 **双亲委派模型** 。

在 **类加载** 时，系统会首先判断当前类是否被加载过：

+ 已经被加载的类会直接返回，否则才会尝试加载。

加载的时候，首先会把该请求委派给**父类加载器**的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。

+ 当父类加载器无法处理时，才由自己来处理。

+ 当父类加载器为 null 时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。

![image-20220731153739081](https://img.zxdmy.com/2022/202207311537586.png)

> **null 并不代表没有父类加载器，而是 `BootstrapClassLoader`** 。
>
> 类加载器之间的“父子”关系不是通过继承来体现的，是由“**优先级**”来决定。

**亲委派模型的好处：**

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。

如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现多个不同的 `Object` 类。

**自定义类加载器：**

除了 `BootstrapClassLoader` ，其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`。

如果我们要自定义自己的类加载器，需要继承 `ClassLoader`。

### 2.2 连接

> **加载阶段** 和 **连接阶段** 的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能已经开始了。

#### 2.2.1 验证

**验证阶段** 主要对文件格式、元数据、字节码、符号引用 进行验证。

![image-20220731154258988](https://img.zxdmy.com/2022/202207311543209.png)

#### 2.2.2 准备

**准备阶段是正式为 `类变量` 分配内存并 `设置类变量初始值` 的阶段**，这些内存都将在方法区中分配。

详情如下：

+ **准备阶段** 只对 **类变量** 进行内存分配（即 Class Variables ，静态变量，被 `static` 关键字修饰的变量），不包括 实例变量（实例变量会在对象实例化时随着对象一块分配在 Java 堆中。）
+ 从概念上讲，类变量所使用的内存都应当在 **方法区** 中进行分配。而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的`字符串常量池`、`静态变量`等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。
+ 这里所设置的**初始值**，通常情况下是数据类型默认的零值（如 0、0L、null、false 等）
    + 如： `public static int value=111` ， value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。
    + 但是：public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。

#### 2.2.3 解析

**解析阶段** 是虚拟机将常量池内的`符号引用替换为直接引用`的过程。

解析动作主要针对`类或接口`、`字段`、`类方法`、`接口方法`、`方法类型`、`方法句柄`和`调用限定符` 7 类符号引用进行。

+ **符号引用**就是一组符号来描述目标，可以是任何字面量。
+ **直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

> 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

### 2.3 初始化

**初始化阶段** 是执行初始化方法 `<clinit> ()` 的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

> 说明： `<clinit> ()`方法是编译之后自动生成的。

对于`<clinit> ()` 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 `<clinit> ()` 方法是**带锁线程安全**，所以在多线程环境下进行类初始化的话可能会引起多个进程阻塞，并且这种阻塞很难被发现。

以下 5 种情况，必须对类进行初始化：

1. 当遇到 `new` 、 `getstatic`、`putstatic` 或 `invokestatic` 这 4 条直接码指令时（比如 `new` 一个类， 读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时）：
    - 当 jvm 执行 `new` 指令时会初始化类。即**当程序创建一个类的实例对象**。
    - 当 jvm 执行 `getstatic` 指令时会初始化类。即**程序访问类的静态变量**(不是静态常量，常量会被加载到运行时常量池)。
    - 当 jvm 执行 `putstatic` 指令时会初始化类。即程序给类的静态变量赋值。
    - 当 jvm 执行 `invokestatic` 指令时会初始化类。即程序调用类的静态方法。
2. 使用 `java.lang.reflect` 包的方法对类进行**反射调用**时，如 `Class.forname("...")`, `newInstance()` 等等。如果类没初始化，需要触发其初始化。
3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 `main` 方法的那个类)，虚拟机会先初始化这个类。
5. `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 `findStaticVarHandle` 来初始化要调用的类。

另外：当一个接口中定义了 JDK8 新加入的**默认方法**（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化

### 2.4 卸载

卸载类即该类的 Class 对象被 GC。

卸载类需要满足 3 个要求:

1. 该类的所有的实例对象都已被 GC，也就是说堆**不存在该类的实例对象**。
2. 该类在其他任何地方**没有被引用**
3. 该类的**类加载器的实例已被 GC**

> 由 jvm 自带的类加载器（ `BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` ）加载的类是不会被卸载的，因为它们负责加载 JDK 提供的类。但由我们自定义的类加载器加载的类是可能被卸载的。

## 3、垃圾回收（GC）

> 如果没有特殊说明，都是针对的是 HotSpot 虚拟机。

当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。

Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 **堆** 内存中对象的分配与回收。

Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。

从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永久代(Permanent Generation)

下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。

![image-20220731165419362](1-4、Java 虚拟机（JVM）.assets/image-20220731165419362.png)

### 4.1 内存的分配与回收





### 4.2 死亡对象的判断



### 4.3 类型引用



### 4.4 废弃常量与无用类



#### 无用类







### 4.5 垃圾收集算法

#### 标记-清除 算法





#### 标记-复制 算法





#### 标记-整理 算法





#### 分代收集算法





### 4.6 垃圾收集器

#### Serial 收集器



#### ParNew 收集器



#### Parallel Scavenge 收集器



#### Serial Old 收集器



#### Parallel Old 收集器



#### CMS 收集器



#### G1 收集器



#### ZGC 收集器





## 4、JVM 参数与调优







## jvm 调优

## 什么时候会发生 GC

## 有哪些 GC 方式

## 服务器 oom 了怎么解决

##  G1 回收器和 CMS 区别

## G1 垃圾回收器有什么参数需要配置吗

## 比如 try catch 在 jvm 怎么实现的，

## GC算法：新生代、老年代