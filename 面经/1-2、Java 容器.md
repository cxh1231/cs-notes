# 1-2　Java容器

## 1、Java容器概述

**Java容器** 主要由 `Collection` 和 `Map` 两大接口派生而来。

这两大接口派生的各个接口和实现类，如下图所示。

![image-20220725101728777](https://img.zxdmy.com/2022/202207251017896.png)

+ `Collection` 表示**集合**（类似数组），主要用于存放单一元素；
  + `List`  表示**列表**（顺序），其存储的元素有序、可重复；
  + `Queue` 表示**队列**（排队），其存储的元素有序、可重复；
    + Deque 表示
  + `Set`  表示**集合**（独一无二），其存储的元素无序、不可重复；
    + Sorted
+ `Map` 表示**映射**，主要用于存放键值对；
  + `Map` 的 key 是无序、不可重复的，value 是无序、可重复的， key 与value 一一对应。

## 2、容器分类详解

### 2.1 List 列表 实现类

|     类     |   简介   |   线程   | null | 底层数据结构（实现）                           |
| :--------: | :------: | :------: | :--: | ---------------------------------------------- |
|   Vector   | 动态数组 | **安全** |  Y   | `Object[]` 数组                                |
|   Stack    |    栈    | **安全** |  Y   |                                                |
| ArrayList  | 动态数组 |  不安全  |  Y   | `Object[]` 数组                                |
| LinkedList | 双向链表 |  不安全  |  Y   | 双向链表（JDK1.6 为循环链表，JDK1.7 取消循环） |

+ Vector：是 List 的古老实现类。
+ Stack：栈，先进后出。
+ **ArrayList**：
  + **自动扩容**：默认初始容量 `10`，默认最大 `MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8`；
    + 新添加元素前，调用 `ensureCapacityInternal()` 方法，进行判断是否需要扩容；
    + 将新容量 `new` 扩充为原来的 `1.5` 倍，即 `new = old + (old >> 1)`；
    + 如果新容量 `new` 小于 最小需要容量 `min`，则 `new = min`；
    + 如果新容量 `new` 大于 `MAX_ARRAY_SIZE` ，则 `new = Integer.MAX_VALUE`。
  + **增删元素复杂度**：由于采用数组存储，**插入和删除受元素位置的影响**。
    + 直接添加元素时，追加在末尾，复杂度 `O(1)`；
    + 指定位置添加或删除元素，需要将后续的`(n-i)`个元素向前/后移动，复杂度为 `O(n-i)`。
  + **快速随机访问**：支持，可以通过元素序号快速获取元素对象；
  + **内存空间占用**：列表末尾会预留预定义的数组空间；
  + 构造（不指 ≤ JDK6）：
    + 无参数构造方法创建 `ArrayList` 时，初始化赋值为一个空数组；
    + 当向数组中添加第一个元素时，才分配容量，即容量扩为 默认值 10。
+ **LinkedList**：
  + **增删元素复杂度**：由于采用链表存储，
    + 直接添加/删除元素时，**不受元素位置影响**，复杂度 `O(1)`；
    + 指定位置添加或删除元素，**需要先移动至指定位置再进行操作**，复杂度为  `O(n)`。
  + **快速随机访问**：不支持高效的随机元素访问；
  + **内存空间占用**：每个元素需要多消耗前驱、后继数据。

### 2.2 Queue 队列 实现类

|      类       |   简介   |  线程  | null  | 实现                                  |
| :-----------: | :------: | :----: | :---: | :------------------------------------ |
| PriorityQueue | 有序队列 | 不安全 | **N** | `Object[]` 数组来实现的二叉**小顶堆** |
|  ArrayDeque   | 双端队列 | 不安全 | **N** | `Object[]` 数组 + 双指针              |

**详细说明：**

+ **PriorityQueue**：
  + **自动扩容**：默认容量 `11`，当队列长度小于 `64` 扩容`2`倍，否则扩容 `1.5` 倍，扩容后超出 `int` 范围赋值为 `Integer.Max_VALUE`，最小需要容量小于0，说明超出`int`范围，则抛出`OOM`异常。
  + 线程问题：非线程安全，不支持并发访问和修改。但是Java提供了`PriorityBlockingQueue`（实现 BlockingQueue 接口，使用 ReentrantLock 加锁保护）用于Java多线程环境。
+ **ArrayDeque**：
  + **自动扩容**：最小容量 `8`，默认容量 `16` ，二者不一的原因是其使用`allocateElements`方法扩容，对 8 进行特定计算后得二进制 10000，故默认容量为 16。容量必须是 2^n^ ，即每次扩容两倍。
  + 线程问题：非线程安全，不支持并发访问和修改。多线程环境需要自行处理。
  + 可克隆，可序列化，可迭代遍历。

### 2.3 Set 集合 实现类

|      类       |     简介     |  线程  | 实现                       |
| :-----------: | :----------: | :----: | -------------------------- |
|    HashSet    |   无序集合   | 不安全 | 基于 `HashMap` 实现        |
| LinkedHashSet |   无序集合   | 不安全 | 通过 `LinkedHashMap` 实现  |
|    TreeSet    | **有序**集合 | 不安全 | 红黑树(自平衡的排序二叉树) |

**详细说明：**



### 2.4 Map 映射 实现类

|      类       |     简介     |   线程   | null  | 实现                                                         |
| :-----------: | :----------: | :------: | :---: | ------------------------------------------------------------ |
|    HashMap    |   无序映射   |  不安全  |   Y   | 长度 < 8：数组 + 链表（链表散列）<br/>长度 >= 8 ：数组 + 链表 \| 红黑树 |
| LinkedHashMap | **有序**映射 |  不安全  |   Y   | 数组 + 链表 \| 红黑树；双向链表                              |
|   Hashtable   |   无序映射   | **安全** | **N** | 数组 + 链表                                                  |
|    TreeMap    | **有序**映射 |  不安全  | **N** | 红黑树（自平衡的排序二叉树）                                 |

**详细说明：**

+ **HashMap**：用来存放键值对，基于哈希表的 Map 接口实现。
  + **存储结构**：
    + 在JDK1.8 之前使用 `数组+链表` ，其中数组是主体，链表的作用是解决哈希冲突（“拉链法”解决冲突），即当元素出现哈希冲突时，会存储在该位置的单链表中。
    + JDK1.8 及之后，使用 `数组 + 链表 | 红黑树` ，即长链表在下面的情况下，会转化为红黑树。
  + **哈希值计算**：
    + 先调用 `key` 的 `hashCode()` 方法，计算 原始哈希值；
    + 然后调用 `HashMap` 的 `hash()` 方法，对 原始哈希值 进行扰动，以减少哈希碰撞。
    + 扰动方法：`(h = key.hashCode()) ^ (h >>> 16)` （ ^ ：按位异或；>>>：无符号右移）
  + **自动扩容**（JDK1.8）：
    + 哈希表（数组）的默认初始大小为 `16`，每次扩容为原来 `2` 倍。
    + 某个单链表元素超过 `8` 个，但是数组总长度不超过 `64`：扩容；
    + 某个单链表元素超过 `8` 个，并且数组总长度超过 `64`：该节点的链表转化为红黑树；
    + 由于删除或调整操作，某个红黑树的节点 `≤6` 个：恢复链表形态。
      ![image-20220727142139825](https://img.zxdmy.com/2022/202207271421976.png)
  + 性能影响参数：“初始容量” 和 “加载因子”
    + `加载因子` 是哈希表在其容量自动增加之前可以达到多满的一种尺度
    + 默认加载因子是 0.75 ，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数（即容量）。
  + 元素添加详细流程：
    ![image-20220727100923304](https://img.zxdmy.com/2022/202207271009092.png)
+ **LinkedHashMap**：
  + **简介**：是HashMap的子类，其内部还有一个`双向链表`维护键值对的顺序，每个键值对既位于哈希表中，也位于双向链表中。
  + **有序**：
    + 插入顺序：先添加的在前面，后添加的在后面。修改操作不影响顺序；
    + 访问顺序：每次`get/put`所访问的元素，将被移动至链表末尾（故末尾是最近访问的，是最久没有被访问的）

  + 访问速度比较慢

+ **Hashtable**：
  + 哈希值计算：直接采用 key 的 hashCode()
  + 扩容机制：
    + 初始容量为 11，负载因子默认 0.75 ；
    + 当 `已用容量 > 总容量 * 负载因子` 时，扩容：`newsize = olesize*2 + 1`；

  + Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。

+ **TreeMap**：







ArrayList 和 LinkedList 的区别

Java 里有哪些队列容器，哪些是线程安全的

HashMap、HashTable、ConcurrentHashMap

ConcurrentHashMap 的 size 和 get 是线程安全的吗

HashMap的Get流程？线程安全？如何选择线程安全的容器？

## ArrayList 的扩容？

## ArrayList 在 JVM 里怎么存的？







