**Depth First Search** 即 **DFS**，意为**深度优先搜索**，是所有的搜索手段之一。它是从某个状态开始，不断进行状态转移，直到不能转移后，向后回退，一直到遍历完所有的状态。

### 1、DFS的基本概念

作为搜索算法的一种，DFS 主要是用于解决 NP 完全问题。但是，深度优先搜索算法的时间复杂度较高，深度优先搜索是 *O(n!)*的阶乘级算法，它的效率非常低，在数据规模变大时，此算法就难以解决当前的问题了。

所以搜索算法使用于状态节点较小规模的问题。

### 2、DFS设计步骤

按照定义设计：

1. 确定该题目的状态（包括边界）
2. 找到状态转移方式
3. 找到问题的出口，计数或者某个状态
4. 设计搜索

伪代码：

```text
int check(参数)
{
    if(满足条件)
        return 1;
    return 0;
}
bool pd(参数){
    相应操作
}
void dfs(int step)
{
        判断边界pd()
        {
            不在边界内，即回溯
        }
        尝试每一种可能
        {
               满足check条件

               标记

               继续下一步dfs(step+1)

               恢复初始状态（回溯的时候要用到）
        }
}
```

### 3、例题：N皇后文档

**题目描述:**

八皇后问题（英文：Eight queens），是由国际象棋棋手马克斯·贝瑟尔于1848年提出的问题，是回溯算法的典型案例。

问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。

高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。

如果经过±90度、±180度旋转，和对角线对称变换的摆法看成一类，共有42类。

而我们今天要挑战的是N皇后的问题，即在NxN 的棋盘上，放置N 个皇后，使得它们不相互攻击（即任意 2 个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成 45° 角的斜线上。

你的任务是，对于给定的 N，求出有多少种合法的放置方法。

**输入描述:**

```txt
输入中有一个正整数 N≤10，表示棋盘和皇后的数量
```

**输出描述:**

```txt
为一个正整数，表示对应输入行的皇后的不同放置数量。
```

**输入输出样例:**

**示例:**

**输入:**

```txt
5
```

**输出:**

```txt
10
```

**运行限制:**

```txt
最大运行时间：1s
最大运行内存: 256M
```

**题目解析：**

下面是用递归的深度优先搜索求解 n 皇后问题的算法描述：

这里用一个 N\*N 的矩阵来表示棋盘，但是我们不需要定义这样的数组，只要心中有 N\*N 的棋盘即可。

1. 算法开始：

   当前行设为第一行，当前列设为第一列，从第一行第一列开始搜索，即只能让皇后从第一行放到第 n 行。

   这样在每次判断是否满足情况时我们不用去判断是否皇后在相同行。

   我们只用判断之前的 1 到 a-1 个皇后的位置和当前第 a 个皇后的位置是否属于同一列或者斜线，判断是否同一列。

2. 判断边界：

   在当前行，当前列的位置上判断是否满足条件(即保证经过这一点的行,列与斜线上都没有两个皇后)，若不满足，跳到第 5 步，即不符合边界条件。

   首先说一下，什么叫不符合边界条件，不只是跳出了搜索范围，剪枝也可以从这里开始，比如这里不满足条件，向下继续搜索也不会再有结果。

   这可以理解为超出边界的剪枝，我们的边界只得可能存在解的范围，这里已经超出有解的范围，必然要被踢出。

   判断条件：

   我们用数组 x[a]=i 来表示第 a 个皇后的位置在第 a 行第 i 列，我们不用考虑是否在同一行的问题你，我们只用判断之前的 1 到 a-1 个皇后的位置和当前第 a 个皇后的位置是否属于同一列或者斜线。

   判断是否属于同一列： 就判断 x[a]是否等于 x[i]; 判断是否属于同一斜线：等同于判断行之差是否等于列之差也，即 abs(x[k]-x[i])||x[k]==x[i]。

3. 搜索过程：

   调用 Check 函数。

   如果 边界条件，就继续调用放下一个皇后的位置

4. check(参数):

   如果当搜索到第 N+1 行的时候，即代表前 N 行已经搜索完了，所以这个时候正好求出了一个解，记录加一。

5. 在当前位置上不满足条件的情形，进行回溯。

**答案解析：**

```java
import java.util.Scanner;

public class Main {

    // N*N的棋盘：下标表示横坐标，下标对应的值，表示纵坐标（这样定义，横坐标永远不会重复！）
    static int x[] = new int[15];
    // sum是总的递归到底的次数（也就是摆放的种类），n是棋盘大小。
    static int SUM = 0, N;

    /**
     * 判断该点能不能放这个棋子
     *
     * @param k 当前纵坐标可以不用放
     * @return
     */
    static boolean PD(int k) {
        // 遍历
        for (int i = 1; i < k; i++) {
            // 判断两个皇后是否在对角线上
            if (Math.abs(k - i) == Math.abs(x[k] - x[i])) {
                return false;
            }
            // 判断是否在同一列上
            else if (x[k] == x[i]) {
                return false;
            }
        }
        return true;
    }

    /**
     * 计数（找到递归到底的状态）
     *
     * @param a
     * @return
     */
    static boolean check(int a) {
        // 已经到了最后一个坐标，则可放的次数自增
        if (a > N) {
            SUM++;
            return true;
        }
        return false;
    }

    /**
     * 深度优先搜索
     *
     * @param a 皇后的个数
     */
    static void DFS(int a) {
        // 递归结束条件（最后一个皇后放入棋盘了）
        if (check(a)) {
            return;
        }
        // 还有皇后没放，则继续
        else {
            for (int i = 1; i <= N; i++) {
                // 记录第a个皇后的列数
                x[a] = i;
                // 判断第a个皇后，能否放在这一步
                if (PD(a)) {
                    // 可以放的话，就继续下一个皇后的位置
                    DFS(a + 1);
                }
                // 不能就下一列
                else {
                    continue;
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // 获取皇后个数
        N = scanner.nextInt();
        // 每次都从第一个皇后开始
        DFS(1);
        // 输出结果
        System.out.println(SUM);
    }

}
```

### 4、例题：路径之谜

**题目描述:**

小明冒充 XXX 星球的骑士，进入了一个奇怪的城堡。

城堡里边什么都没有，只有方形石头铺成的地面。

假设城堡地面是 n*n 个方格。如下图所示。

![地图](https://img.zxdmy.com/2022/202205201031635.png)

按习俗，骑士要从西北角走到东南角。

可以横向或纵向移动，但不能斜着走，也不能跳跃。

每走到一个新方格，就要向正北方和正西方各射一箭。 (城堡的西墙和北墙内各有 nnn 个靶子)

同一个方格只允许经过一次。 但不必走完所有的方格。

如果只给出靶子上箭的数目，你能推断出骑士的行走路线吗？

有时是可以的，比如上图中的例子。

> 本题的要求就是已知箭靶数字，求骑士的行走路径（测试数据保证路径唯一）

**输入:**

```txt
输入描述:

第一行一个整数 N (0≤N≤20)，表示地面有 N×N 个方格。

第二行 N 个整数，空格分开，表示北边的箭靶上的数字（自西向东）

第三行 N 个整数，空格分开，表示西边的箭靶上的数字（自北向南）
```

**输出：**

```txt
输出描述:

输出一行若干个整数，表示骑士路径。

为了方便表示，我们约定每个小格子用一个数字代表，从西北角开始编号: 0,1,2,3 ⋯

比如，上图中的方块编号为：
```

| 箭靶 | 2    | 4    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- |
| 4    | 0    | 1    | 2    | 3    |
| 3    | 4    | 5    | 6    | 7    |
| 3    | 8    | 9    | 10   | 11   |
| 3    | 12   | 13   | 14   | 15   |

**输入输出样例：**

输入

```txt
4
2 4 3 4
4 3 3 3
```

输出

```txt
0 4 5 1 2 3 7 11 10 9 13 14 15
```

**运行限制:**

```txt
最大运行时间：1s
最大运行内存: 128M
```

**题目解析：**

这里用一个 N*N 的矩阵来表示城堡的位置，横向、纵向标号 1-N。

我们采用逆推法，既然原题目是走到哪里射一支箭，那我们就走到那里之后拔一支箭，如果最后得到所有的靶子上都没有箭了，由于题目的路径唯一，那就证明我们找到了题目所要求的路径。

1. 算法开始：

   当前行设为第一行，当前列设为第一列，从第一行第一列开始搜索。

   然后从左上角初始位置，按照题目意思进行寻路。

2. 判断边界：

   在当前行，当前列的位置上判断是否满足条件，若不满足，跳到第 5 步，即不符合边界条件。 判断条件如下：

    1. flag\[x]\[y]==1 标记数组已经被标记 已被走过，不能再走，超出边界
    2. x<1 从左侧走出方格
    3. x>n 从右侧走出方格
    4. y<1 从上侧走出方格
    5. y>n 从下侧走出方格
    6. col[x]<=0 没走到右下角，箭用完了
    7. rol[y2]<=0 没走到右下角，箭用完了

3. 搜索过程：

   调用 Check 函数。

   如果边界条件满足，就继续调用搜索，找到下一步的位置

4. check(参数):

   如果当搜索到 x=n,y=n 时，且靶子上的箭都没了，按就找到了答案。

   按照题目输出即可。

5. 在当前位置上不满足条件的情形，进行回溯，并还原现场

**答案解析：**

```java
import java.util.Scanner;

public class Main {

    static final int N = 30;
    // 横向箭靶的数字
    static int rol[] = new int[N];
    // 纵向箭靶的数字
    static int col[] = new int[N];
    // 用来标记是否走过
    static boolean flag[][] = new boolean[N][N];

    // 格子数 长宽从1到n
    static int n;
    // 记录走过的路径的横纵坐标
    static int resX[] = new int[1000];
    static int resY[] = new int[1000];
    // 走过的点的个数
    static int resCount = 0;

    // ---------图的路径搜索常用方向移动表示-------
    static int dx[] = {0, 1, -1, 0};
    static int dy[] = {1, 0, 0, -1};
    // 两两组合形成上下左右四个方向

    // 1------------------> x
    // |
    // |
    // |
    // |
    // |
    // |
    // |
    // ↓
    // y

    // dx[0]=0 dy[0]=1 那么代表向下的方向
    // dx[1]=1 dy[1]=0 那么代表向右的方向
    // dx[2]=-1 dy[0]=0 那么代表向左的方向
    // dx[3]=0 dy[1]=-1 那么代表向上的方向

    /**
     * 判断走过的路径的箭靶数是否与目标相同
     *
     * @param x 路径的x坐标
     * @param y 路径的y坐标
     * @return
     */
    static boolean check(int x, int y) {
        // 如果走到了最后一个点，停止搜索
        if (x == n && y == n) {
            // 遍历箭靶
            for (int i = 1; i <= n; i++) {
                // 如果箭靶上的数目不为 0，根据逆推，我们通过当前路径得不到箭靶上的结果
                if (col[i] != 0 || rol[i] != 0) {
                    return false;
                }
            }
            // 恰好符合箭靶上的要求，可以输出结果（已知路径唯一，不会有其他的路径）
            for (int i = 0; i < resCount; i++) {
                // x 轴坐标
                int x2 = resX[i];
                // y 轴坐标
                int y2 = resY[i];
                // 通过计算的到为题目要求的坐标系
                int sum = n * (x2 - 1) + y2 - 1;
                System.out.print(sum + " ");
            }
            System.out.println();
            // 成功终止
            return false;
        }
        // 继续搜索
        return true;
    }

    /**
     * 判断是否走过、是否越界、是否用完箭
     *
     * @param x2
     * @param y2
     * @return
     */
    static boolean pd(int x2, int y2) {
        // 已被走过，不能再走，超出边界
        if (flag[x2][y2]) {
            return false;
        }
        // 超出四个边界，不能继续走
        else if (x2 < 1 || x2 > n || y2 < 1 || y2 > n) {
            return false;
        }
        // 该点的箭用完了，不能继续走
        else if (col[x2] <= 0 || rol[y2] <= 0) {
            return false;
        }
        // 符合边界条件，可以继续执行搜索
        else {
            return true;
        }
    }

    /**
     * 深度优先搜索
     *
     * @param x
     * @param y
     */
    static void dfs(int x, int y) {
        // 判断该点：是否到了最后一个点
        // 包含不符合规则的地方，回溯，用于剪枝
        if (!check(x, y)) {
            return;

        }
        // 没有到最后一个点，继续搜索
        else {
            // 向四个方向走，依次是：下、右、左、上
            for (int i = 0; i < 4; i++) {
                // 计算下一个点的坐标
                int xt = dx[i] + x;
                int yt = dy[i] + y;
                // 下一个点坐标越界（不符合通行条件，换方向搜索）
                if (!pd(xt, yt)) {
                    continue;
                }
                // 该点可以通行
                else {
                    // 因为要进行位置转移，我们给它起个名字，叫[作案现场]

                    // 标记已走过
                    flag[xt][yt] = true;
                    // 箭靶的箭的数目自减
                    col[xt]--;
                    rol[yt]--;
                    // 记录路径
                    resX[resCount] = xt;
                    resY[resCount] = yt;
                    // 路径点的数目自增
                    resCount++;

                    // 继续深搜
                    dfs(xt, yt);

                    // 搜索回溯后，因为没有找到正确答案，所以要恢复[作案现场]，返回到搜索之前的状态
                    resCount--;
                    flag[xt][yt] = false;
                    col[xt]++;
                    rol[yt]++;
                }
            }
        }
    }

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Scanner in = new Scanner(System.in);
        // 方格的边长
        n = in.nextInt();
        // 横向箭靶的数字
        for (int i = 1; i <= n; i++)
            rol[i] = in.nextInt();
        // 纵向箭靶的数字
        for (int i = 1; i <= n; i++)
            col[i] = in.nextInt();
        // 起点记录走过
        flag[1][1] = true;
        // 起点处的箭靶数字自减（已走过）
        col[1]--;
        rol[1]--;
        // 记录初始的路径点
        resX[resCount] = 1;
        resY[resCount] = 1;
        // 走过的路径自增
        resCount++;
        // 深度优先搜索
        dfs(1, 1);
    }

}
```

