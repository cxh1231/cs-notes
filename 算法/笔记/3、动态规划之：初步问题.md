# 动态规划之 初步问题

**动态规划（Dynamic Programming）**是一种**多阶段的决策过程最优化**的问题。

本文主要讲述动态规划的基本思想与算法步骤。

## 1、动态规划算法解决的问题

首先需要回忆一下**贪心问题**。

**贪心算法**又称**贪婪算法**。是一种在每一步选择中都采取在当前状态下最好、最优、最有利的选择，从而使得问题得到全局最优解。

**贪心算法有如下特点：**

+ 贪心选择的性质，是指**所求问题的整体最优解可以通过一系列局部最优的选择（即贪心选择）来求解**，即给出问题，每一步都选择最优的情况，最终的总体选择求出的答案，也是最优的。（这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别）
+ 贪心选择要求**每个选择过程无后效性**，即该问题每一步的选择，对后续的选择没有影响。

当该问题的每个决策过程**具有后效性**的话就不能采用贪心算法，需要通过动态规划算法解决。

**一句话概况：动态规划是为了解决贪心算法无法解决的问题。**

## 2、多阶段决策过程最优化问题

### 2.1 多阶段决策问题

**多阶段决策过程问题**，就是一类在每一阶段都需要做出选择，并且某一阶段的决策受前面所有阶段决策后的状态影响，同时该阶段的决策又会影响后续的决策。

这样一类问题就是**多阶段决策问题**。

### 2.2 多阶段决策过程最优化问题

在**多阶段决策问题**中，各个阶段采取的决策，通常与**时间**，或者其他的**线性变量**有关。

前文提到，某个阶段的决策，是在该阶段前面已经做完的决策形成的某种状态后，开始进行决策的。

同时，现在这个阶段做的决策，又会使得状态进行转移，该转移后的状态，又影响了下次决策的状态。

所以说，**作决策时的状态是动态**的，**规划是解决最优化问题的方式**。

因此，**解决这种多阶段决策过程最优化的方法叫做动态规划**。

## 3、动态规划

动态规划问题，是运筹学的一个分支，动态规划主要用于求解**以时间、线性变量划分阶段的动态过程**的优化问题。

在实际生活中，动态规划问题与贪心问题相似，都是完成某一事件的过程可以划分成多个阶段。

但是与贪心不同的是**动态规划的每个状态之间都会相互影响、相互干涉**，也就是说在**某一阶段做出的决策会影响整个事件的最终结果**。因为阶段是有先后的，所以某一阶段的选取，受到之前阶段的选取的影响，该阶段的选取也会影响后面的阶段。

### 3.1 动态规划的术语解释

- **阶段**： 把求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解。过程不同，阶段数就可能不同；
- **状态**： 描述事物的性质。不同事物有不同的性质，因而用不同的状态来刻画。对问题的求解状态的描述是分阶段的；
- **决策**： 根据题意要求，对每个阶段所做出的某种选择性操作；
- **策略**： 由每个阶段的决策组成的序列称为策略；
- **状态转移方程**： 用数学公式描述与阶段相关的状态间的演变规律。

### 3.2 能采用动态规划求解的问题的性质

- **最优化原理**：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。

- **无后效性**：即某阶段的状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。

- **有重叠子问题**：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

### 3.3 解题步骤

- 拆分问题
- 定义状态（并找出初状态）
- 状态转移方程

### 3.4 一般的模型方法

- 递归搜索法
- 记忆化搜索（记忆化暴力）
- 递推式法

## 4、经典例题

### 4.1 数塔问题

**题目描述:**

如下所示为一个数字三角形。请编一个程序，计算从顶到底的某处的一条路径，使该路径所经过的数字总和最大。只要求输出总和。

![图片描述](https://img.zxdmy.com/2022/202205291639967.png)

要求：

1. 一步可沿左斜线向下或右斜线向下走；
2. 三角形行数小于等于 100；
3. 三角形中的数字范围为 0 到 99；
4. 测试数据通过键盘逐行输入。

**输入描述:**

第一行包含一个整数 N ，表示三角形的总行数。

接下来的 N 行，是三角形每行的数据。

```txt
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

**输出示例：**

```txt
30
```

**运行限制:**

+ 最大运行时间：1s
+ 最大运行内存：128M

**题目分析:**

解决该题目的方式有很多，包括动态规划， 枚举都可以解决这个问题。

我们从递推的思想出发，假设我们从顶层沿着某条路径已经走到了第 $i$ 层，正向着 $i+1$ 层前进。

两条可行路径中我们肯定会选择最大的方向前进。

为此我们可以采用递推中的反向递推，即**逆推**的方式解决，设 $a[i][j]$ 存放从 $i$ , $j$ 出发到达第 $n$ 层的最大值。

我们可以写出递推式：

$$ a[i][j] = max \{ a[i][j]+a[i+1][j],a[i][j]+a[i+1][j+1] \} $$

则逆推到出发点 a\[1][1]为题目所求答案，即第一层到第 N 层的最大值。

**答案解析：**

```java
import java.util.Scanner;

public class Main {

    // 存放整个数组
    static int[][] a = new int[101][101];

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // 输入总行数
        int n = scanner.nextInt();
        // 依次输入三角形每一行的值
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                a[i][j] = scanner.nextInt();
            }
        }
        // 递推开始：从最后一层逆推，但是最后一层无需修改，直接从倒数第二层开始循环
        for (int i = n - 1; i >= 1; i--) {
            for (int j = 1; j <= i; j++) {
                // 路径选择：
                // 如果当前点的正下方的值大于右下方的值，则正下方的值
                if (a[i + 1][j] >= a[i + 1][j + 1]) {
                    a[i][j] += a[i + 1][j];
                }
                // 否则，选择右下方的值
                else {
                    a[i][j] += a[i + 1][j + 1];
                }
            }
        }
        // 遍历至第一行，即为最大值
        System.out.println(a[1][1]);
    }
}
```

**答案详解：**

其实前文的题目分析所用到的思想就是动态规划。现在换种方式再理解一遍。

在用动态规划考虑数塔问题时可以**自顶向下的分析，自底向上的计算**。

从顶点出发时到底向左走还是向右走，应取决于向左走能取到最大值，还是向右走能取到最大值。

只有左右两道路径上的最大值求出来了才能作出决策。

同样的道理下一层的走向又要取决于下下一层上的最大值是否已经求出才能决策。

这样一层一层推下去，直到倒数第二层时就非常明了。

所以第一步对第五层的 8 个数据，做如下四次决策：

- 如果经过第四层 2，则在第五层的 4 和 5 中，决策选择的肯定是 19 ；
- 如果经过第四层 7，则在第五层的 5 和 2 中，决策选择的肯定是 10 ；
- 如果经过第四层第一个 4，则在第五层的 2 和 6 中，决策选择的肯定是 6 ；
- 如果经过第四层第二个 4，则在第五层的 6 和 5 中，决策选择的肯定是 6 。

经过一次决策，问题降了一阶。5 层数塔问题转换成 4 层数塔问题，经过如此的决策，就将原来问题转换为一阶数塔问题。

于是我们可以用我们上面的递推求解。

这就是**递推式法模型**。

### 4.2 游戏中的学问

难度: 简单 标签: DP, JSOI, 2013

题目链接：https://www.lanqiao.cn/problems/1436/learning/

**题目描述：**

手拉手围着篝火跳舞时，大家会围成一个大圈，每个人的左手拉着旁边朋友的右手，右手拉着另一侧朋友的左手。

不过，如果每一个人都随机的拉住两个不同人的手，然后再慢慢散开，事情就变得有趣多了：此时大家依旧会形成圈，不过，可能会形成多个独立的圈。

当然这里我们依然要求一个人的右手只能拉另一个人的左手，反之亦然。

班里一共有 N 个同学，由 1 到 N 编号。

想知道究竟有多少种本质不同的拉手方案，使得最终大家散开后恰好形成 k 个圈？

给定两种方案，若存在一个人和他的一只手，满足在这两种方案中，拉着这只手的人的编号不同，则这两种方案本质不同。

**输入描述：**

输入一行包含三个正整数 $N$ ， $k$ ， $P$ 。

其中，$3 ≤ k ≤ N ≤ 3000, 10^4 ≤ p ≤ 2×10^9$ 。

**输出描述：**

输出一行一个整数，表示本质不同的方案数对 p 的余数。保证 p 一定是一个质数。

**输入输出示例：**

Input：

```txt
3 1 1000000009
```

output：

```txt
2
```

**答案解析：**

题目是说随机拉住右手，共计 N 个人形成 k 个独立环的可能的情况有多少种。

我们举个例子，A B C 三个人：

![图片描述](https://img.zxdmy.com/2022/202206082011846.png)

A 的左手是 C A 的右手是 B B 的左手是 A B 的右手是 C C 的左手是 B C 的右手是 A

![图片描述](https://img.zxdmy.com/2022/202206082011237.png)

A 的左手是 B A 的右手是 C B 的左手是 C B 的右手是 A C 的左手是 A C 的右手是 B

这两种是不同的。

最后对 P 取模。

这道题目可以说是记忆化搜索，也可以说是递推法模型。

**1、定义状态：**

我们设 $dp\{i,j\}$ 是 i 个人组成 j 个圈有多少种情况的状态。

**2、找初始状态：**

由于最少是三个人围成 1 个圈，所以 $dp\{3,1\}=2$ 。

**3、找状态转移：**

**首先考虑人数。**

当考虑到 $dp\{4,1\}$ 时：由于初始状态三个人之间共计 3 个空位置，第四个人可以见缝插针，有 3 种选择，所以就有 $dp\{4,1\}=3×dp\{3,1\}$ 。

接着考虑 $dp\{x+1,y\}$ 和 $dp\{x,y\}$ 的关系：

假设 X 个人分成 y 个环后，每个环的人数是 $X_1 X_2 ... X_y$ ，

+ 对于第一个环 $X_1$ 来说，共有 $X_1$ 个空
+ 对于第二个环 $X_2$ 来说，共有 $X_2$ 个空
+ ……

最终，共计 $X_1+X_2+...+X_y=X$ 个空，那么第 $X+1$ 个人就有 X 种选择。

所以 $dp\{x+1,y\}=x×dp\{x,y\}$，即 $dp\{i,j\}=(i-1)*dp\{i-1,j\}$ 。

**接着考虑圈数。**

比如 $dp\{6,1\}$ 和 $dp\{6,2\}$ ，划分阶段的方式是是圈数吗？

如果是圈数，但是 $\{6,1\}$ 和 $\{6,2\}$ 两个状态之间没有什么关系。所以单纯的圈数不存在关系。

已知，至少需要 3 个人才能组成一个圈。

所以当第 $i$ 个人加入时，要在前 $i-1$ 个人中，抽出两个人才能组成一个新的圈。

所以原本的 $dp\{i-1,j\}$ 的状态就变成了 $dp\{i-3,j\}$ 。

由于是从 $i-1$ 个人中抽出 2 个人，所以共计有 $C_{i-1}^{2}$ 种抽取方式，同时已知 3 个人有两种组合方案。

所以根据组合数，求方案数的方式如下：

$2 \times C_{i-1}^{2} = 2 \times \frac{(i-1)!}{(i-3)!\times2}$

即：

$2 \times C_{i-1}^{2}=(i-1)!/(i-3)!=(i-1)*(i-2)$

所以 $dp\{i,j+1\}=dp\{i-3,j\}×(i-1)×(i-2)$

即 $dp\{i,j\}=dp\{i-3,j-1\}×(i-1)×(i-2)$

**至此，我们可以得到两种情况的状态转移方程：**

- $dp\{i,j\}=dp\{i-1,j\}×(i-1)$
- $dp\{i,j\}=dp\{i-3,j-1\}×(i-1)×(i-2)$

此外，还需要考虑：建不建立新圈，都是 $dp\{i,j\}$ 的情况。

所以这里的两个状态转移方程，不是相等的关系，而是求和的关系:

1. $dp\{i,j\}=dp\{i-1,j\}×(i-1)$
2. $dp\{i,j\}=dp\{i,j\}+dp\{i-3,j-1\}×(i-1)×(i-2)$

比如：

+ $dp\{7,2\}$ 可以由 $dp\{6,2\}$ 转移而来；

+ $ dp\{7,2\}$ 也可以由 $dp\{4,1\}$ 转移而来。

为什么这两种情况没有重叠，而是绝对异构的？因为：

+ $dp\{6,2\}$ 由 $dp\{3,1\}$ 转移而来
+ $dp\{4,1\}$ 由 $dp\{3,1\}$ 转移而来

这个转移过程中，$dp\{4,1\}$ 里的 1-4 号是在同一个圈内的，而 $dp\{6,2\}$ 里的两个圈，是 6 个人中的任意 3 个在一个圈内，不可能出现 1-4 在一个圈里的这种情况。

所以推导出：

+ $dp\{i,j\}$ 由 $dp\{i-1,j\}$ 转移而来，也可以由 $dp\{i-3,j-1\}$ 转移而来；
    + $dp\{i-1,j\}$ 可以由 $dp\{i-2,j\} $ 或者 $dp\{i-4,j-1$} 转移而来；
    + $dp\{i-3,j-1\}$ 可以由 $dp\{i-4,j-1\}$ 或者 $dp\{i-6,j-2\}$ 转移而来。
        + ……

最终还是会到 $dp\{3,1\}$ 。

所以基于 $dp\{3,1\}$ ，通过两种方式，走向了完全不同的方向。

至此我们轻松写出代码。

```java
import java.util.Scanner;

public class Main {

    // 二维dp数组，i表示人数，j表示组数
    public static long dp[][] = new long[3100][3100];

    public static int n, k;

    public static void main(String[] args) {
        // 输入基础数据
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextInt();
        k = scanner.nextInt();
        long mod = scanner.nextLong();
        // 初始化：3人1组时，有2中组合方式
        dp[3][1] = 2;
        // 从4人组合开始
        for (int i = 4; i <= n; i++) {
            // 分组的个数，保证一组至少有3人，并且组数不能超过限制
            for (int j = 1; 3 * j <= i && j <= k; j++) {
                // 情况1：组数不变，加人
                dp[i][j] = dp[i - 1][j] * (i - 1) % mod;
                // 情况2：加人的同时，多分出一组
                // 同时加上前面的情况1的组合数
                dp[i][j] = (dp[i][j] + dp[i - 3][j - 1] * (i - 1) * (i - 2)) % mod;
            }
        }
        // 输出结果
        System.out.println(dp[n][k]);
    }
}
```

### 4.3 跳跃问题

难度: 简单 标签: 动态规划, 搜索, 2021, 模拟赛

题目链接：https://www.lanqiao.cn/problems/553/learning/

**题目描述：**

小蓝在一个 n 行 m 列的方格图中玩一个游戏。

开始时，小蓝站在方格图的左上角，即第 1 行第 1 列。

小蓝可以在方格图上走动，走动时，如果当前在第 r 行第 c 列，他不能走到行号比 r 小的行，也不能走到列号比 c 小的列。同时，他一步走的直线距离不超过 3。

例如，如果当前小蓝在第 3 行第 5 列，他下一步可以走到：

+ 第 3 行第 6 列
+ 第 3 行第 7 列
+ 第 3 行第 8 列
+ 第 4 行第 5 列
+ 第 4 行第 6 列
+ 第 4 行第 7 列
+ 第 5 行第 5 列
+ 第 5 行第 6 列
+ 第 6 行第 5 列

小蓝最终要走到第 n 行第 m 列。

在图中，有的位置有奖励，走上去即可获得，有的位置有惩罚，走上去就要接受惩罚。奖励和惩罚最终抽象成一个权值，奖励为正，惩罚为负。

小蓝希望，从第 1 行第 1 列走到第 n 行第 m 列后，总的权值和最大。请问最大是多少？

**输入描述：**

输入的第一行包含两个整数 n, m，表示图的大小。

接下来 n 行，每行 m 个整数，表示方格图中每个点的权值。

其中，$1≤n≤100$ ， $−10^4≤权值≤10^4$ 。

**输出描述：**

输出一个整数，表示最大权值和。

**输入输出样例：**

Input：

```txt
3 5
-4 -5 -10 -3 1
7 5 -9 3 -10
10 -2 6 -10 -4
```

output：

```txt
15
```

**运行限制:**

- 最大运行时间：1s
- 最大运行内存: 128M

**答案解析：**

由于这道题目数据较弱，大家可以使用搜索把所有情况都搜索到，每次到终点就保存最大值，直到遍历完所有的情况，然后输出最大值。

> 在这之前，先通过 DFS 求解，然后再通过 DP 求解。
>
> 有时动态规划要从状态出发，有时动态规划又可以看成暴力搜索的剪枝。

**搜索解法：**

因为只能向右下方移动，不存在走回头路的情况，所以不需要设置 Vis 数组。

```java
import java.util.Scanner;

public class Main {

    public static int n, m, Sum = Integer.MIN_VALUE;

    // 权重地图
    public static int[][] mapTable = new int[105][105];

    public static int next[][] = {
            {0, 1}, // ↓
            {0, 2}, // ↓ ↓
            {0, 3}, // ↓ ↓ ↓
            {1, 0}, // →
            {2, 0}, // → →
            {3, 0}, // → → →
            {1, 1}, // ↓ →
            {1, 2}, // ↓ → →
            {2, 1}  // ↓ ↓ →
    };

    /**
     * 深度优先搜索
     *
     * @param x     横坐标
     * @param y     纵坐标
     * @param value 权重值
     */
    public static void dfs(int x, int y, int value) {
        // 上一步的权重最大值加上当前节点的值
        value += mapTable[x][y];
        // 如果已经到了出口，则返回
        if (x == n && y == m) {
            Sum = Math.max(Sum, value);
            return;
        }
        // 向 9 个位置移动
        for (int i = 0; i < 9; i++) {
            // 计算移动后的横纵坐标
            int tx = x + next[i][0];
            int ty = y + next[i][1];
            // 如果移动后还在地图上，则计算深搜
            if (tx <= n && ty <= m) {
                dfs(tx, ty, value);
            }
        }
    }

    public static void main(String[] args) {
        // 输入数据
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                mapTable[i][j] = in.nextInt();
        // 深搜
        dfs(1, 1, 0);
        // 输出最大值
        System.out.println(Sum);
    }
}
```

**动态规划：**

**定义状态：**

我们设 dp{i,j} 当走到第 i 行第 j 列的值。

**1、找初始状态：**

初始状态很简单，就是第一个点： $dp\{1,1\} = weight$ 。

**2、找状态转移：**

对于 $dp\{i,j\}$ ，会有 9 种不同的状态转移，我们很难知道当前的选择去怎样影响后续的值。

这就是前文搜索方法的问题，我们难以找到一种 DP 思路去求解这个问题。

但是反向考虑：既然 $dp\{i,j\}$ 会有 9 种转移方式，那么当这 9 种状态的值，是从这 9 种状态到达终点的最优解（最大值）时，我们就能得到 $dp\{i,j\}$ 的最大值，就是这 9 种最优解的最大值。

继续消解子问题，那么就得到了这 9 种最优子状态，继续根据同样的原理得到这 9 种最优的子状态的最优子状态，依次类推……

持续消解，当到了 $dp\{n,m\}$ 时，终止消解。

这就是一个递归的过程。

**通过递归正向求解的解题方法如下。**

```c
import java.util.Scanner;

public class Main {
	public static int n, m, Sum = Integer.MIN_VALUE;

	// 权重地图
	public static int[][] mapTable = new int[105][105];

	public static int next[][] = { { 0, 1 }, // ↓
			{ 0, 2 }, // ↓ ↓
			{ 0, 3 }, // ↓ ↓ ↓
			{ 1, 0 }, // →
			{ 2, 0 }, // → →
			{ 3, 0 }, // → → →
			{ 1, 1 }, // ↓ →
			{ 1, 2 }, // ↓ → →
			{ 2, 1 } // ↓ ↓ →
	};

	public static int dp(int x, int y) {
		// 到了最后一个点，返回值
		if (x == n && y == m) {
			return mapTable[n][m];
		}
		// 越界
		else if (x > n || y > m) {
			return Integer.MIN_VALUE;
		}
		// 临时最大值
		int maxTemp = Integer.MIN_VALUE;
		// 选择9个点的最大值
		for (int k = 0; k < 9; k++) {
			int tx = x + next[k][0];
			int ty = y + next[k][1];
			maxTemp = Math.max(maxTemp, dp(tx, ty));
		}
		// 返回当前节点与后续最大值的和
		return mapTable[x][y] + maxTemp;
	}

	public static void main(String[] args) {
		// 输入数据
		Scanner in = new Scanner(System.in);
		n = in.nextInt();
		m = in.nextInt();
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				mapTable[i][j] = in.nextInt();
			}
		}
		// 逆向遍历
		System.out.println(dp(1, 1));
	}
}
```

这个过程是正推。这个题目数据量较小，用递归写不会爆。

其实，根据递归写出递推，这就变成了逆推。

其实逆推式并不是根据动态规划写出来的，而是用正推递归变递推变来的。

正推也是可以写出递推式。

**逆推后的解题算法如下。**

```java
import java.util.Scanner;

public class Main {
    public static int n, m, Sum = Integer.MIN_VALUE;

    // 权重地图
    public static int[][] mapTable = new int[105][105];

    public static int next[][] = {{0, 1}, // ↓
            {0, 2}, // ↓ ↓
            {0, 3}, // ↓ ↓ ↓
            {1, 0}, // →
            {2, 0}, // → →
            {3, 0}, // → → →
            {1, 1}, // ↓ →
            {1, 2}, // ↓ → →
            {2, 1} // ↓ ↓ →
    };

    public static void main(String[] args) {
        // 输入数据
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        m = in.nextInt();
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                mapTable[i][j] = in.nextInt();
            }
        }
        // 逆向遍历
        for (int i = n; i >= 1; i--) {
            for (int j = m; j >= 1; j--) {
                // 最后一个节点跳过
                if (i == n && j == m) {
                    continue;
                }
                // 临时最大值
                int maxTemp = Integer.MIN_VALUE;
                // 选择9个点的最大值
                for (int k = 0; k < 9; k++) {
                    int tx = i + next[k][0];
                    int ty = j + next[k][1];
                    // 越界忽略
                    if (tx > n || ty > m)
                        continue;
                    maxTemp = Math.max(maxTemp, mapTable[tx][ty]);
                }
                // 修改该点的最大值
                mapTable[i][j] += maxTemp;
            }
        }
        System.out.println(mapTable[1][1]);
    }
}
```

> https://www.lanqiao.cn/courses/5194/learning/?id=495921